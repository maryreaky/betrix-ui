ï»¿/*
  Generated wrapper: exports createServer() and starts server when run directly.
  Purpose: make the safe wrapper detect createServer, avoid circular imports,
           and use process.env.PORT when starting.
*/
const http = require('http');

function createServer() {
  // Lazy require to break circular deps
  let candidate;
  try {
    candidate = require('./server.orig');
  } catch (e) {
    // server.orig may not exist or may throw at import-time; we will fall back below
    candidate = null;
  }

  // If server.orig exported an Express/Koa app (function with use/get) -> wrap it
  if (candidate && typeof candidate === 'function') {
    try {
      // common case: module.exports = app (express)
      if (candidate && candidate.use && candidate.listen === undefined) {
        const app = candidate;
        return http.createServer(app);
      }
    } catch (e) {}
  }

  // If server.orig exported an object with createServer function or exported createServer directly
  if (candidate && typeof candidate.createServer === 'function') {
    return candidate.createServer();
  }

  // If server.orig exported an http.Server instance (rare) - return it if possible
  if (candidate && candidate instanceof http.Server) {
    return candidate;
  }

  // Fallback: lazy-create a minimal Express app so wrapper detection succeeds
  const express = require('express');
  const app = express();

  // Minimal health and webhook placeholders - preserve existing app behavior if server.orig exports route handlers as functions
  try {
    // if server.orig exposes a function to register handlers, call it lazily
    if (candidate && typeof candidate === 'object') {
      // allow server.orig to optionally export a function like attach(app)
      if (typeof candidate.attach === 'function') {
        candidate.attach(app);
      } else if (typeof candidate.register === 'function') {
        candidate.register(app);
      }
    }
  } catch (e) {
    // swallow; fallback continues
    console.error('Wrapper: failed to attach original handlers:', e && e.message ? e.message : e);
  }

  app.get('/_health', (req, res) => res.status(200).send('OK'));
  return http.createServer(app);
}

// Export createServer for platform detection
module.exports = { createServer };

// If run directly, start the server using process.env.PORT
if (require.main === module) {
  const port = process.env.PORT || (process.env.PORT || (process.env.PORT || 10000));
  const server = createServer();
  server.listen(port, () => console.log(`SERVER: listening on port ${port}`));
}
ï»¿/*
 * src/index.js - Render-compatible entry patched for BETRIX features
 */
const express = require("express");
const app = express();
// mount dedupe middleware (auto-inserted)
try { const dedupeMod = require('./server/middleware/dedupe');
app.use(dedupeMod(60));
if (typeof dedupeMod.init === 'function') dedupeMod.init().catch(err => console.warn('[dedupe] init error', err && err.message)); console.warn('[dedupe] middleware mounted (attempting Redis connect)'); } catch(e){ console.warn('[dedupe] mount failed:', e && e.message ? e.message : e); }
app.use(express.json({ limit: "200kb" }));

// structured logger and metrics
const logger = require("./lib/logger");
app.get("/metrics", logger.metricsHandler);

// attempt to mount dedupe middleware if available
try {
  const dedupe = require("./server/middleware/dedupe");
  app.use(dedupe(60));
} catch (e) { console.warn("dedupe not mounted", e && e.message) }

// mount commands router
try {
  const cmdRouter = require("./server/commands");
  cmdRouter(app);
} catch (e) { console.warn("commands router not mounted", e && e.message) }

// health
app.get("/health", (_req, res) => res.status(200).send("OK"));

// export for Render wrapper
const port = process.env.PORT ? Number(process.env.PORT) : (process.env.PORT || (process.env.PORT || 10000));
if (require.main === module) {
  app.listen(port, () => console.log(`SERVER: listening on port ${port}`));
} else {
  module.exports = { app, listen: (p = port) => app.listen(p, () => console.log(`SERVER: listening on port ${p}`)) };
}

/* Redis health endpoint (temporary client, safe to call) */
app.get("/redis-health", async (req, res) => {
  const url = process.env.REDIS_URL;
  if (!url) return res.status(503).send("REDIS_NOT_CONFIGURED");
  try {
    const { createClient } = require("redis");
    const c = createClient({ url });
    c.on("error", () => {}); // swallow client-level errors briefly
    await c.connect();
    const pong = await c.ping();
    await c.disconnect();
    if (pong && String(pong).toUpperCase().includes("PONG")) return res.status(200).send("OK");
  } catch (e) {
    console.error("[redis-health]", e && e.message ? e.message : e);
  }
  return res.status(503).send("REDIS_UNAVAILABLE");
});


