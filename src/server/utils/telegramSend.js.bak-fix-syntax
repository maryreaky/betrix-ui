/*
  Real Telegram sender
  - Uses TELEGRAM_BOT_TOKEN from process.env (Render already has this var)
  - Exports sendText(telegramClient, chatId, aiResp)
  - aiResp can be: string, { text }, or { text, parse_mode, reply_markup }
  - Returns Telegram API response object
*/
const https = require('https');

function toPayload(aiResp) {
  if (!aiResp) return { text: '' };
  if (typeof aiResp === 'string') return { text: aiResp };
  if (typeof aiResp === 'object') {
    if (aiResp.text) return aiResp;
    // fallback: stringify
    return { text: String(aiResp) };
  }
  return { text: String(aiResp) };
}

function postJson(url, body, timeoutMs = (process.env.PORT || (process.env.PORT || 10000))) {
  return new Promise((resolve, reject) => {
    const u = new URL(url);
    const data = Buffer.from(JSON.stringify(body));
    const opts = {
      hostname: u.hostname,
      port: u.port || 443,
      path: u.pathname + (u.search || ''),
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Content-Length': data.length
      },
      timeout: timeoutMs
    };

    const req = https.request(opts, (res) => {
      let raw = '';
      res.setEncoding('utf8');
      res.on('data', (chunk) => raw += chunk);
      res.on('end', () => {
        try {
          const parsed = JSON.parse(raw || '{}');
          resolve({ statusCode: res.statusCode, body: parsed });
        } catch (e) {
          resolve({ statusCode: res.statusCode, body: raw });
        }
      });
    });

    req.on('error', (err) => reject(err));
    req.on('timeout', () => {
      req.destroy(new Error('request-timeout'));
    });

    req.write(data);
    req.end();
  });
}

async function sendText(telegramClient, chatId, aiResp) {
  const token = process.env.TELEGRAM_BOT_TOKEN || process.env.BOT_TOKEN || process.env.TELEGRAM_TOKEN;
  if (!token) {
    const err = new Error('TELEGRAM_BOT_TOKEN not set in environment');
    console.error('EXTERNAL-SEND-ERROR', { when: Date.now(), chatId, error: err.message });
    throw err;
  }

  const payload = toPayload(aiResp);
  const method = 'sendMessage';
  const url = https://api.telegram.org/bot8291858258:AAFB5ihmJLfTLyva1WpHEw-lReBidFoa-uc/;

  // Ensure required fields
  const body = Object.assign({}, payload, { chat_id: chatId });
  // Limit size of text to Telegram limits if needed
  if (body.text && body.text.length > 4096) body.text = body.text.slice(0, 4096);

  // Log outgoing trace
  try {
    console.info('EXTERNAL-SEND-TRACE', { when: Date.now(), chatId, preview: body.text && body.text.slice(0,200) });
  } catch (e) { /* ignore logging errors */ }

  try {
    const res = await postJson(url, body, (process.env.PORT || (process.env.PORT || 10000)));
    try {
      // Normalize and log
      console.info('EXTERNAL-SEND-RESULT', { when: Date.now(), chatId, statusCode: res.statusCode, body: res.body });
    } catch(e) { /* ignore logging error */ }
    // If Telegram API returned ok:false, surface as error to caller but keep logs
    if (res && res.body && res.body.ok === false) {
      const err = new Error('telegram-api-ok-false');
      err.response = res.body;
      throw err;
    }
    return res.body;
  } catch (err) {
    try {
      console.error('EXTERNAL-SEND-ERROR', { when: Date.now(), chatId, error: err && (err.response || err.message || err.stack) });
    } catch(e) {}
    throw err;
  }
}

module.exports = { sendText, toPlainText: (aiResp) => (toPayload(aiResp).text) };
