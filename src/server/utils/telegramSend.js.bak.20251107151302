/*
Persistent telegramSend: env-driven; defensive normalization; setWebhook on boot
*/
const https = require('https');
const { URL } = require('url');

function toPayload(aiResp) {
  if (!aiResp) return { text: '' };
  if (typeof aiResp === 'string') return { text: aiResp };
  if (typeof aiResp === 'object') {
    if (aiResp.text) return { ...aiResp, text: String(aiResp.text) };
    try { return { text: JSON.stringify(aiResp).slice(0,4096) }; } catch(e) { return { text: String(aiResp) }; }
  }
  return { text: String(aiResp) };
}

function extractChatId(arg){
  if (arg === null || arg === undefined) return null;
  if (typeof arg === 'number' || typeof arg === 'string') return arg;
  if (typeof arg === 'object') {
    if (arg.chat && (arg.chat.id || arg.chat_id)) return arg.chat.id || arg.chat_id;
    if (arg.chat_id) return arg.chat_id;
    if (arg.id) return arg.id;
    if (arg.chatId) return arg.chatId;
  }
  return null;
}

function postJson(url, body, timeoutMs = (process.env.PORT || (process.env.PORT || (process.env.PORT || 10000)))){
  return new Promise((resolve, reject) => {
    try {
      const u = new URL(url);
      const data = Buffer.from(JSON.stringify(body));
      const opts = { hostname: u.hostname, port: u.port || 443, path: u.pathname + (u.search || ''), method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Content-Length': data.length }, timeout: timeoutMs };
      const req = https.request(opts, (res) => {
        let raw = '';
        res.setEncoding('utf8');
        res.on('data', (c) => raw += c);
        res.on('end', () => {
          try { resolve({ statusCode: res.statusCode, body: JSON.parse(raw || '{}') }); } catch(e) { resolve({ statusCode: res.statusCode, body: raw }); }
        });
      });
      req.on('error', (err) => reject(err));
      req.on('timeout', () => req.destroy(new Error('request-timeout')));
      req.write(data);
      req.end();
    } catch (err) { reject(err); }
  });
}

async function sendText() {
  const args = Array.from(arguments);
  let chatId = null; let aiResp = null;

  if (args.length === 1) { const obj = args[0]; chatId = extractChatId(obj); aiResp = (typeof obj === 'object' && obj.text) ? obj.text : obj; }
  else if (args.length === 2) { chatId = extractChatId(args[0]) || extractChatId(args[1]); aiResp = (typeof args[1] === 'string' || typeof args[1] === 'object') ? args[1] : args[0]; }
  else if (args.length >= 3) { chatId = extractChatId(args[1]); aiResp = args[2]; }

  if (!chatId) { for (const a of args) { const c = extractChatId(a); if (c) { chatId = c; break; } } }
  if (!aiResp) { for (const a of args) { if (typeof a === 'string') { aiResp = a; break; } } }

  const token = process.env.TELEGRAM_BOT_TOKEN;
  if (!token) { const err = new Error('TELEGRAM_BOT_TOKEN not set'); console.error('EXTERNAL-SEND-ERROR',{when:Date.now(),chatId,error:err.message}); throw err; }

  const payload = toPayload(aiResp);
  const text = payload.text || '';
  if (!text || String(text).trim().length === 0) { console.error('EXTERNAL-SEND-ABORT-EMPTY-TEXT',{when:Date.now(),chatId,preview:payload.text}); const e = new Error('empty-message'); e.code = 'empty-message'; throw e; }

  const apiMethod = 'sendMessage';
  const apiMethod = apiMethod || 'sendMessage';
const url = `https://api.telegram.org/bot${process.env.TELEGRAM_BOT_TOKEN}/${apiMethod}`;

  const body = Object.assign({}, payload, { chat_id: chatId });
  if (body.text && body.text.length > 4096) body.text = body.text.slice(0,4096);

  try { console.info('EXTERNAL-SEND-TRACE',{when:Date.now(),chatId,textPreview:String(body.text).slice(0,200)}); } catch(e){}
  try {
    const res = await postJson(url, body, (process.env.PORT || (process.env.PORT || (process.env.PORT || 10000))));
    try { console.info('EXTERNAL-SEND-RESULT',{when:Date.now(),chatId,statusCode:res.statusCode,body:res.body}); } catch(e){}
    if (res && res.body && res.body.ok === false) { const apiErr = new Error('telegram-api-ok-false'); apiErr.response = res.body; throw apiErr; }
    return res.body;
  } catch (err) {
    try { console.error('EXTERNAL-SEND-ERROR',{when:Date.now(),chatId,error:err && (err.response || err.message || err.stack)}); } catch(e){}
    throw err;
  }
}

// On boot, set webhook if available (idempotent)
(async function ensureWebhook(){
  try {
    const token = process.env.TELEGRAM_BOT_TOKEN;
    const webhookUrl = process.env.WEBHOOK_URL || (process.env.RENDER_EXTERNAL_URL ? process.env.RENDER_EXTERNAL_URL + '/webhook/telegram' : null);
    if (token && webhookUrl) {
      const setUrl = https://api.telegram.org/bot${token}/${apiMethod};
      await postJson(setUrl, { url: webhookUrl }, (process.env.PORT || (process.env.PORT || (process.env.PORT || 10000))));
      console.info('WEBHOOK-BOOT-SET', { when: Date.now(), webhook: webhookUrl });
    } else {
      console.info('WEBHOOK-BOOT-SKIP', { when: Date.now(), webhook: !!webhookUrl, token: !!token });
    }
  } catch(e){ console.error('WEBHOOK-BOOT-ERROR', e && (e.message || e.stack || e)); }
})();

module.exports = { sendText, toPlainText: (ai) => (ai && ai.text) || (typeof ai === 'string' ? ai : '') };


